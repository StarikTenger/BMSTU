# Python
## Типизация и система типов языка
В Python типизация неявная и динамическая, тип при объявлении переменной не указывается и определяется на этапе исполнения программы

### Типы данных
В Python типы данных делятся на встроенные в интерпретатор (built-in) и не встроенные, которые можно использовать при импортировании соответствующих модулей

Основные встроенные типы:

1. None
2. Bool
3. Числа
   1. int
   2. float
   3. complex
4. Списки
   1. list - список
   2. tuple - кортеж
   3. range - диапазон
5. Строки (str)
6. Бинарные списки
    1. bytes – байты
    2. bytearray – массивы байт
    3. memoryview – специальные объекты для доступа к внутренним данным объекта через protocol buffer

7. Множества
    1. set – множество
    2. frozenset – неизменяемое множество

8. Словари (dict)

### Модель данных
Объявление переменной:
```python
x = 3
```
Здесь создаётся целочисленный объект 3 и переменной x присваивается ссылка на него, объект может быть любого типа
Имя переменной не может быть ключевым словом языка, проверяется это функцией *keyword.iskeyword()*
```python
>>> import keyword
>>> keyword.iskeyword("try")
True
>>> keyword.iskeyword("b")
False
```

У каждого объекта есть свой идендификатор, его можно получить функцией *id*:
```python
>>> a = 4
>>> b = 5
>>> id(a)
1829984576
>>> id(b)
1829984592
>>> a = b
>>> id(a)
1829984592
```
Тип переменной можно определить с помощью функции *type()*:
```python
>>> a = 10
>>> b = "hello"
>>> c = (1, 2)
>>> type(a)
<class 'int'>
>>> type(b)
<class 'str'>
>>> type(c)
<class 'tuple'>
```

### Изменяемые и неизменяемые типы данных
В Python существуют изменяемые и неизменяемые типы

Изменяемые:
* числа (int, float, complex)
* логические (bool)
* кортежи (tuple)
* строки (str)
* неизменяемые множества (frozen set)

Неизменяемые:
* списки (list)
* множества (set)
* словари (dict)

## Основные управляющие конструкции
### Оператор if
```python
if <условие1>: <оператор1>
    [elif <условие2>: <оператор2>]* 
    [else: <оператор3>]  
```
Оператор "если". Часть в квадратных скобках является необязательной. Помеченная звёздочкой часть может быть записана неоднократно одна за другой. 

Здесь, при истинности <условия1> будет выполнен <оператор1> и проигнорированы ветки elif и else. В противном случае, если истинно <условие2>, то выполняется <оператор2>, ветка else игнорируется. Иначе выполняется <оператор3>. 

### Оператор while
```python
while <условие>:
    <оператор1> 
[else: <оператор2>]
```
Цикл "пока". <Оператор1> будет выполняться все время, пока истинно <условие>. При нормальном завершении цикла (без применения break), выполнится <оператор2>. 

### Оператор for
```python
for <переменная> in <список>:
    <оператор1> 
[else: <оператор2>]   
```
Цикл "для". <Переменная> пробегает все элементы <списка> и для каждого текущего значения <переменной> выполняется <оператор1>. При нормальном завершении цикла (без применения break), выполнится <оператор2>.

### Оператор break
```python
break
```
Осуществляет немедленное завершение циклов while и for. 

### Оператор continue
```python
continue
```
Вызывает немедленное выполнение следующей итерации циклов while и for.

### Оператор return
```python
return [<результат>]
```
Осуществляет возврат из функции или метода класса, возвращая значение <результат>.

### Оператор def
```python
def <имя функции> ( [<список параметров>] ):
    <тело функции>
```
Здесь <тело функции> - последовательность операторов, выровненных по тексту правее слова "def". 
<список параметров> в самом общем виде выглядит так: 
[ < id > [,< id >]* ] [ < id >=< v > [,< id >=< v >]* ] [, *< id >] 
Здесь < id > - идентификатор переменной; < v > - некое значение. 
Параметры < id > за которыми следует "=" получают значения < v > по умолчанию. 
Если список заканчивается строкой " *< id > ", то id присваивается кортеж из всех оставшихся аргументов, переданных функции.

## Подмножество языка для функционального программирования
Функции в Python являются объектами первого класса, то есть, они могут употребляться в программе наравне с объектами других типов данных.

Функция может быть определена лямбда выражением:
```python
# определения эквивалентны
def func(x, y):
    return x**2 + y**2

func = lambda x, y: x**2 + y**2
```

### Списковые включения
```python
>>> l = [x**2 for x in range(1,10)]
>>> l
[1, 4, 9, 16, 25, 36, 49, 64, 81]
```

### Встроенные функции высших порядков
#### **map**
Применяет функцию к последовательностям
```python
>>> list1 = [7, 2, 3, 10, 12]
>>> list2 = [-1, 1, -5, 4, 6]
>>> map(lambda x, y: x*y, list1, list2)
[-7, 2, -15, 40, 72]
```
#### **filter**
позволяет фильтровать значения последовательности. В результирующем списке только те значения, для которых значение функции для элемента истинно
```python
>>> numbers = [10, 4, 2, -1, 6]
>>> filter(lambda x: x < 5, numbers)
[4, 2, -1]
```
#### **reduce**
Позволяет организовать цепочечные вычисления в списке
```python
>>>from functools import reduce
>>>numbers = [2, 3, 4, 5, 6]
>>> reduce(lambda res, x: res*x, numbers, 1)
720
```

## Важнейшие функции для работы с потоками ввода/вывода, строками, регулярными выражениями
### Ввод/вывод
*input()* возвращает считанное значение ввиде строки
```python
>>> a = input()
1 2
>>> a
'1 2'
```
*print()* выводит строку в stdout
```python
>>> print("jfgn jj")
jfgn jj
```

### Работа со строками
Сложение
```python
>>> S1 = 'spam'
>>> S2 = 'eggs'
>>> print(S1 + S2)
'spameggs'
```
Дублирование
```python
>>> print('spam' * 3)
spamspamspam
```
Нахождение длины
```python
>>> len('spam')
4
```
Индексация (отрицательные индексы считаются с конца строки)
```python
>>> S = 'spam'
>>> S[0]
's'
>>> S[2]
'a'
>>> S[-2]
'a'
```
Извлечение среза

Оператор извлечения среза: [X:Y]. X – начало среза, а Y – окончание;

символ с номером Y в срез не входит. По умолчанию первый индекс равен 0, а второй - длине строки.
```python
>>> s = 'spameggs'
>>> s[3:5]
'me'
>>> s[2:-2]
'ameg'
>>> s[:6]
'spameg'
>>> s[1:]
'pameggs'
>>> s[:]
'spameggs'
```
Можно задать шаг, с которым нужно извлекать срез.
```python
>>> s[::-1]
'sggemaps'
>>> s[3:5:-1]
''
>>> s[2::2]
'aeg'
```

### Регулярные выражения
Регулярные выражения доступны, если импортировать модуль *re*
```python
import re
```
Некоторые методы модуля:
```python
re.match()   # ищет по заданному шаблону в начале строки
re.search()  # ищет по всей строке, но возвращает только первое найденное совпадение
re.findall() # возвращает список всех найденных совпадений
re.split()   #  разделяет строку по заданному шаблону
re.sub()     # ищет шаблон в строке и заменяет его на указанную подстроку
re.compile() # собирает регулярное выражение в отдельный объект, который может быть использован для поиска
```

Операторы регулярных выражений:

| Оператор |  Описание                                                        |
|:--------:|:-----------------------------------------------------------------|
|     .    | Один любой символ, кроме новой строки \n
|     ?    | 0 или 1 вхождение шаблона слева
|     +    | 1 и более вхождений шаблона слева
|     *    | 0 и более вхождений шаблона слева
|    \w    | Любая цифра или буква (\W — все, кроме буквы или цифры)
|    \d    | Любая цифра [0-9] (\D — все, кроме цифры)
|    \s    | Любой пробельный символ (\S — любой непробельный символ)
|    \b    | Граница слова
|   [..]   | Один из символов в скобках
|   [^..]  | Любой символ, кроме тех, что в скобках
|    \     | Экранирование спецсимволов
|   ^ и $  | Начало и конец строки соответственно
|   {n,m}  | От n до m вхождений ({,m} — от 0 до m)
|   a\|b   | Соответствует a или b
|    ()    | Группирует выражение и возвращает найденный текст
|\t, \n, \r| Символ табуляции, новой строки и возврата каретки соответственно